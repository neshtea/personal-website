[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.15.1","content-config-digest","131ad8bdb0d7e6b2","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://defmarco.com\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"i18n\":{\"defaultLocale\":\"de\",\"locales\":[\"de\",\"en\"],\"routing\":{\"prefixDefaultLocale\":false,\"redirectToDefaultLocale\":true,\"fallbackType\":\"redirect\"}},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,37,38,62,63,87,88],"en/second-post",{"id":11,"data":13,"body":17,"filePath":18,"digest":19,"rendered":20,"legacyId":36},{"title":14,"description":15,"date":16},"Another Post","Continuing to build out the blog",["Date","2024-02-01T00:00:00.000Z"],"# Another Post\n\nHere's another example blog post to show how the blog listing works.\n\n## Deployment Instructions\n\nTo deploy on Cloudflare Pages:\n\n1. Push your code to GitHub/GitLab\n2. Connect your repository to Cloudflare Pages\n3. Set build command: `npm run build`\n4. Set build output directory: `dist`\n5. Deploy!\n\nYour site will automatically rebuild on every push.","src/content/blog/en/second-post.md","7422b2fe3ff76827",{"html":21,"metadata":22},"\u003Ch1 id=\"another-post\">Another Post\u003C/h1>\n\u003Cp>Here’s another example blog post to show how the blog listing works.\u003C/p>\n\u003Ch2 id=\"deployment-instructions\">Deployment Instructions\u003C/h2>\n\u003Cp>To deploy on Cloudflare Pages:\u003C/p>\n\u003Col>\n\u003Cli>Push your code to GitHub/GitLab\u003C/li>\n\u003Cli>Connect your repository to Cloudflare Pages\u003C/li>\n\u003Cli>Set build command: \u003Ccode>npm run build\u003C/code>\u003C/li>\n\u003Cli>Set build output directory: \u003Ccode>dist\u003C/code>\u003C/li>\n\u003Cli>Deploy!\u003C/li>\n\u003C/ol>\n\u003Cp>Your site will automatically rebuild on every push.\u003C/p>",{"headings":23,"localImagePaths":31,"remoteImagePaths":32,"frontmatter":33,"imagePaths":35},[24,27],{"depth":25,"slug":26,"text":14},1,"another-post",{"depth":28,"slug":29,"text":30},2,"deployment-instructions","Deployment Instructions",[],[],{"title":14,"description":15,"date":34},["Date","2024-02-01T00:00:00.000Z"],[],"en/second-post.md","en/first-post",{"id":37,"data":39,"body":43,"filePath":44,"digest":45,"rendered":46,"legacyId":61},{"title":40,"description":41,"date":42},"My First Blog Post","This is the first post on my new website",["Date","2024-01-15T00:00:00.000Z"],"# Welcome\n\nThis is my first blog post. I'm excited to share my thoughts and ideas here.\n\n## Getting Started\n\nYou can write your content using Markdown. It supports all standard Markdown features.\n\n- Lists\n- **Bold text**\n- _Italic text_\n- `Code snippets`\n\n```javascript\nconsole.log(\"Hello, world!\");\n```","src/content/blog/en/first-post.md","011354edc3cfbfdf",{"html":47,"metadata":48},"\u003Ch1 id=\"welcome\">Welcome\u003C/h1>\n\u003Cp>This is my first blog post. I’m excited to share my thoughts and ideas here.\u003C/p>\n\u003Ch2 id=\"getting-started\">Getting Started\u003C/h2>\n\u003Cp>You can write your content using Markdown. It supports all standard Markdown features.\u003C/p>\n\u003Cul>\n\u003Cli>Lists\u003C/li>\n\u003Cli>\u003Cstrong>Bold text\u003C/strong>\u003C/li>\n\u003Cli>\u003Cem>Italic text\u003C/em>\u003C/li>\n\u003Cli>\u003Ccode>Code snippets\u003C/code>\u003C/li>\n\u003C/ul>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">console.\u003C/span>\u003Cspan style=\"color:#B392F0\">log\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Hello, world!\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">);\u003C/span>\u003C/span>\u003C/code>\u003C/pre>",{"headings":49,"localImagePaths":56,"remoteImagePaths":57,"frontmatter":58,"imagePaths":60},[50,53],{"depth":25,"slug":51,"text":52},"welcome","Welcome",{"depth":28,"slug":54,"text":55},"getting-started","Getting Started",[],[],{"title":40,"description":41,"date":59},["Date","2024-01-15T00:00:00.000Z"],[],"en/first-post.md","de/first-post",{"id":62,"data":64,"body":68,"filePath":69,"digest":70,"rendered":71,"legacyId":86},{"title":65,"description":66,"date":67},"Mein erster Blog-Post","Dies ist der erste Beitrag auf meiner neuen Website",["Date","2024-01-15T00:00:00.000Z"],"# Willkommen\n\nDies ist mein erster Blog-Post. Ich freue mich darauf, hier meine Gedanken und Ideen zu teilen.\n\n## Los geht's\n\nDu kannst deine Inhalte mit Markdown schreiben. Es unterstützt alle Standard-Markdown-Funktionen.\n\n- Listen\n- **Fetter Text**\n- _Kursiver Text_\n- `Code-Snippets`\n\n```javascript\nconsole.log(\"Hallo, Welt!\");\n```","src/content/blog/de/first-post.md","c755e4c9f62472a1",{"html":72,"metadata":73},"\u003Ch1 id=\"willkommen\">Willkommen\u003C/h1>\n\u003Cp>Dies ist mein erster Blog-Post. Ich freue mich darauf, hier meine Gedanken und Ideen zu teilen.\u003C/p>\n\u003Ch2 id=\"los-gehts\">Los geht’s\u003C/h2>\n\u003Cp>Du kannst deine Inhalte mit Markdown schreiben. Es unterstützt alle Standard-Markdown-Funktionen.\u003C/p>\n\u003Cul>\n\u003Cli>Listen\u003C/li>\n\u003Cli>\u003Cstrong>Fetter Text\u003C/strong>\u003C/li>\n\u003Cli>\u003Cem>Kursiver Text\u003C/em>\u003C/li>\n\u003Cli>\u003Ccode>Code-Snippets\u003C/code>\u003C/li>\n\u003C/ul>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">console.\u003C/span>\u003Cspan style=\"color:#B392F0\">log\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Hallo, Welt!\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">);\u003C/span>\u003C/span>\u003C/code>\u003C/pre>",{"headings":74,"localImagePaths":81,"remoteImagePaths":82,"frontmatter":83,"imagePaths":85},[75,78],{"depth":25,"slug":76,"text":77},"willkommen","Willkommen",{"depth":28,"slug":79,"text":80},"los-gehts","Los geht’s",[],[],{"title":65,"description":66,"date":84},["Date","2024-01-15T00:00:00.000Z"],[],"de/first-post.md","de/transducer",{"id":87,"data":89,"body":92,"filePath":93,"digest":94,"rendered":95,"legacyId":119},{"title":90,"description":90,"date":91},"Transducer: Komposition, Abstraktion, Performance",["Date","2018-03-22T00:00:00.000Z"],"Funktionen höherer Ordnung wie `map`, `fold`, `filter` sind aus keinem funktionalen Programm wegzudenken.\nMit ihrer Flexibilität sind sie das Mittel der Wahl für Operationen auf Kollektionen aller Art.\nAllerdings beschränkt sich ihr Anwendungsbereich nicht nur auf klassische Listen oder Vektoren.\nIn diesem Artikel betrachten wir fundamentalere Eigenschaften dieser Operationen und werfen\ninsbesondere einen Blick auf die sogennanten Transducer in der Programmiersprache Clojure.\n\n\u003C!-- more start -->\n\nAusserdem werden wir sehen, wie wir mit Hilfe von sinnvoller Abstraktion nicht\nnur sehr gute Wiederverwendbarkeit sondern auch eine höhere Performance erreichen\nkönnen.\n\n## Alles ist ein fold\n\nWer sich in der Vergangenheit mit der funktionalen Programmierung auseinandergesetzt hat ist eventuell schon mit dieser Aussage vertraut.\nFalls Sie dazu bislang keine Gelegenheit hatten (oder Ihr Gedächtnis auffrischen wollen) betrachten wir zuerst eine Variante der üblichen Definitionen von `map` und `filter`.\n(Hinweis: Alle Beispiele sind in Clojure geschrieben, daher nennen wir `fold` ab diesem Punkt bei seinem Clojure-Namen `reduce`):\n\n```clojure\n(defn map\n  \"Takes a function f and applies it to every element of xs.\"\n  [f xs]\n  (if (empty? xs)\n    xs\n    (cons (f (first xs)) (map f (rest xs)))))\n\n(defn filter\n  \"Takes a predicate pred and returns a list with all elements\n  of xs that satisfy pred.\"\n  [pred xs]\n  (if (empty? xs)\n    xs\n    (if (pred (first xs))\n      (cons (first xs) (filter pred (rest xs)))\n      (filter pred (rest xs)))))\n```\n\nSo oder so ähnlich finden sich viele Defintionen und verschiedenen Standardbibliotheken.\nWie die Überschrift dieses Abschnitts schon verrät lassen sich beide Funktionen auch über `fold` (oder eben `reduce`) definieren.\nDie Signatur von `reduce` sieht, in Haskellnotation ausgedrückt, so aus `(b -> a -> b) -> b -> [a] -> b` (in diesem Fall spezialisiert für Listen).\n\n```clojure\n(defn mapping\n  \"Takes a function f and returns a function.\n    The returned function takes a collection acc\n    and an element x and appends x applied to f to the end of acc.\"\n  [f]\n  (fn [acc x] (conj acc (f x))))\n\n(defn map\n  \"Takes a function f and applies it to every element of xs.\"\n  [f xs]\n  (reduce (mapping f) [] xs))\n\n(defn filtering\n  \"Takes a predicate pred and returns a function.\n    The returned function takes a collection acc\n    and an element x and appends x to the end of acc if it satisfies pred.\"\n  [pred]\n  (fn [acc x] (if (pred x) (conj acc x) acc)))\n\n(defn filter\n  \"Takes a predicate pred and returns a list with all\n    elements of xs that satisfy pred.\"\n  [pred xs]\n  (reduce (filtering pred) [] xs))\n```\n\nWürden unsere Programme ausschließlich aus Listenverarbeitung bestehen könnten wir an dieser Stelle zufrieden aufhören.\nEtwas sticht jedoch ins Auge: sieht man einmal von dem Aufruf an `conj` ab verraten uns die Definitionen von `mapping` und `filtering`\nnichts darüber, dass sie \"nur\" auf Kollektionen arbeiten!\n\n## Von Kollektionen zu Prozessen\n\nWir haben festgestellt, dass die Verbindung zu Kollektionen von unseren `mapping` und `filtering` Funktionen nur über das `conj` besteht.\nNun gehen wir einen Schritt weiter und sehen uns an was passiert, wenn wir über `conj` abstrahieren.\nDafür ist es hilfreich nicht an Listen sondern Sequenzen von Schritten zu denken.\n`mapping` und `filtering` nehmen hierbei die Rolle von \"Prozessmodifikationen\" an: sie nehmen einen Schritt entgegen und liefern eine modifizierte Version dieses Schrittes.\nDefinieren wir also eine über diesen \"Schritt\" parametrisierte Version unserer Funktionen:\n\n```clojure\n(defn mapping\n  [f]\n  (fn [step]\n    (fn [acc x] (step acc (f x)))))\n\n(defn map\n  [f xs]\n  (reduce ((mapping f) conj) [] xs))\n\n(defn filtering\n  [pred]\n  (fn [step]\n    (fn [acc x] (if (pred x) (step acc x) acc))))\n\n(defn filter\n  [pred xs]\n  (reduce ((filtering pred) conj) [] acc))\n```\n\nBetrachten wir nun die daraus resultierenden Definitionen von `mapping` und `filtering` stellen wir fest, dass die Datenstruktur, auf die diese nun operieren\nüber den `step` Parameter festgelegt wird. Das bedeutet, dass wir nun nicht mehr von klassischen Kollektionen abhängig sind, sondern uns (wie wir später noch sehen werden),\nmehr oder weniger beliebige Datenstrukturen vornehmen und diese mit Hilfe von `mapping` und `filtering` verarbeiten können.\n\nEine Überlegung für diesen Schritt steht aber noch aus: während Listen und Vektoren es einfach machen, über einen \"Anfang\" und ein \"Ende\" nachzudenken,\nvon dem wir in `map` und `filter` Gebrauch machen, sieht es mit Datenstrukturen wie Streams oder Signalen anders aus.\nAnstatt uns auf die Datenstruktur zu verlassen gehen wir einen anderen Weg:\n\n1. Unsere Transformatoren (`mapping`, `filtering`) sollten von sich aus ein Konzept von \"Anfang\" und \"Ende\" haben.\n2. Wir erwarten von unserer `step` Funktion nicht nur, dass sie binär ist, sondern auch, dass sie, aufgerufen mit keinem oder einem Argument, einen \"Null\"-Wert produziert.\n   Beispiele hierfür wären in Clojure `(conj) => []`, `(conj [1]) => [1]` oder `(+) => 0`, `(+ 1) => 1`, etc.\n\nWir kümmern uns an dieser Stelle nur um Punkt 1. Wir werden zuerst eine Implementierung von `mapping` und `filtering` vorschlagen.\nIm Codebeispiel unten machen wir gebrauch von Clojures Syntax für \"arity overloading\".\nDas heisst, wir können in einer Funktion mehrere Implementierungen für verschiedene Anzahlen von Argumenten anbieten (mehr dazu auf [Clojure - Functional Programming](https://clojure.org/about/functional_programming#_first_class_functions)).\nClojure wird hierbei abhängig von der Anzahl der übergebenen Argumente die entsprechende Implementierung wählen.\n\n```clojure\n(defn mapping\n  [f]\n  (fn [step]\n    (fn\n      ([] (step))  ; 1.\n      ([acc] (step acc))  ; 2.\n      ([acc x] (step acc (f x)))  ; 3.\n    )))\n\n(defn filtering\n  [pred]\n  (fn [step]\n    (fn\n      ([] (step))\n      ([acc] (step acc))\n      ([acc x] (if (pred x)\n                  (step acc x)\n                  acc)))))\n```\n\nAuf den ersten Blick sieht das vielleicht etwas unintuitiv aus, ist aber am Beispiel von `mapping` schnell erklärt. Die Nummerierung entspricht hier der Zahlen im obenstehenden Codebeispiel.\n\n1. Dieser Fall deckt den \"Anfang\" eines Prozesses ab. Es wurde noch nichts berechnet und es liegt noch keine \"nächste\" Berechnung vor.\n   In diesem Fall wollen wir von unserer `step` Funktion ein \"neutrales\" Element, mit dem wir die Bechnung lostreten können.\n2. Hier signalisieren wir das \"Ende\" eins Prozesses. Es kommmt kein Element mehr nach, also machen wir den letzten Schritt mit dem schon vorliegenden \"Ergebnis\".\n3. Schliesslich existiert noch unser Fall, der das aktuelle Ergebnis und ein Element miteinander verarbeitet.\n\nDiese Funktionen sind nun so weit parametrisiert, dass wir beliebige Prozesse damit ausdrücken und, vermutlich noch wichtiger, mehrere solcher Prozessmodifikationen\nhintereinander ausführen (oder komponieren) können!\n\nWie sieht das in der Realität aus?\n\n## Beispiele für Prozessmodifikatoren\n\nIm Folgenden geben wir zwei Beispiele dafür, wie uns das Ganze nun in der echten Welt hilft und wann wir dieses Vorgehen möglicherweise der regulären Verkettung von Listenoperationen vorziehen wollen.\n\nIn beiden Beispielen beschäftigen wir uns mit folgendem Problem:\nDas Semester ist zuende und die Professorin möchte wissen, wie gut die Durchschnittliche Leistung ihrer Masterstudent\\*innen im Übungsbetrieb war.\nMit Hilfe von Clojure-Spec definieren wir einige Beispieldaten.\nDie ersten vier Zeilen definieren die \"Form\" unserer Daten.\nDabei ist z.B. `::title` ein Wert, der das `string?`-Prädikat erfüllt, in der\nfünften Zeile geben wir `::exercise` als als Map mit den Schlüsseln an, die\ndarüber definiert wurden.\nDie Ausgabe von `sample` wurde hier etwas aufgehübscht, das tatsächliche Ergbnis\nsähe wohl etwas offentichtlich zufälliger aus.\nWer mehr zu Spec erfahren möchte kann das\n[in einem älteren Blog-Artikel tun](http://funktionale-programmierung.de/2016/11/18/clojure-spec.html).\n\n````clojure\n(ns my.namespace\n  (:require [clojure.spec.alpha :as s]\n            [clojure.spec.gen.alpha :as sgen]))\n\n(s/def ::title string?)\n(s/def ::student string?)\n(s/def ::points (set (range 31)))\n(s/def ::degree #{::msc ::bsc})\n(s/def ::exercise (s/keys :req [::title ::student ::points ::degree]))\n\n\n;; `sample` takes a generator for our `spec` and returns some random data that\n;; matches this spec.\n(sgen/sample (s/gen ::exercise))\n;; =>\n;; [{::name \"Marco\"\n;;   ::title \"Exercise 1\"\n;;   ::points 29\n;;   ::degree ::msc}\n;;  {::name \"Mathias\"\n;;   ::title \"Exercise 1\"\n;;   ::points 28\n;;   ::degree ::bsc}\n;;  ...]\n```clojure\n\nZurück zu unserer Aufgabe. Diese liesse sich mit regulären Listenfunktionen zum\nBeispiel so lösen:\n\n```clojure\n(defn sum-of-msc\n  [exercises]\n  (reduce + 0 (->> exercises\n                    (filter #(= ::msc (::degree %)))\n                    (map ::handins))))\n````\n\nAngewendet auf eine Liste von Übungen liefert es uns das richtige Ergebnis.\nEs gibt allerdings ein Problem: Jeder Aufruf von `filter`, `map` und `reduce` berechnet eine neue Liste!\nBei großen Mengen kann das, wie wir gleich sehen werden, durchaus zu Problemen führen.\n\nAls nächstes implementieren wir die gleiche Funktionalität, ausgedrückt über unsere neu definierten Operatoren.\n\nDer erste Schritt wird eine leicht modifizierte Version von `reduce` names\n`reduce-with` sein. Diese funktioniert ganz ähnlich wie `reduce`, ausser, dass sie\nzusätzlich zur Reduktionsfunktion (hier `step`) einen Paramterer `xf` erwartet,\nwelcher eine Komposition unserer Funktionen darstellt.\n\n```clojure\n(defn reduce-with\n  \"Takes a function composed of process modifications xf,\n    a step function,\n    an initial value and a sequence of operations.\n    Applies xf with a step to every x in xs.\"\n  [xf step init xs]\n  (let [f (xf step)]\n    (f (reduce f init xs))))\n```\n\nIm Inneren der Funktion rufen wir wie gewohnt `reduce` auf.\nAls Reduktionsfunktion kommt allerdings die Kompositionsfunktion `xf` zum Einsatz,\nwelche über den `step` Parameter (selbst eine Funktion) für die Auswertung spezialisiert und\nand `f` gebunden wird.\nAnschliessend wird reduziert und das Ergebnis zum Schluss noch einmal mit `f`\naufgerufen, um ein finales Ergebnis zu erzeugen.\n\nWie muss allerdings das `xf` aussehen?\nDiese Funktion ist, ganz analog zu `sum-of-msc` oben, ebenfalls eine Komposition\nvon `filtering` und `mapping`. Wir nennen sie an dieser Stelle `xform` (eine\nKonvention in der Clojurewelt).\n\n{% highlight clojure %}\n;; Compose two process modificators into one.\n(def xform (comp\n(filtering #(= ::msc (::degree %)))\n(mapping ::points)))\n{% endhighlight %}\n\nEventuell fragen Sie sich zurecht, warum sich die Reihenfolge der Aufrufe von `filtering`\nund `mapping` nicht verändert, da Komposition \"von rechts nach links\" ausgewertet\nwird, das Threading in unserer `sum-of-msc` aber von \"links nach rechts\" passiert.\nAn dieser Stelle würde die vollständige Antwort den Rahmen sprengen. Wir merken\nuns für den Moment einfach, dass die Komposition dieser Art von Funktion ebenfalls\n\"von rechts nach links\" auswertet.\nSie können das sehr leicht herausfinden, indem sie die Kopmposition der Funktionen\neinmal von Hand vollständig reduzieren.\n\n{% highlight clojure %}\n(defn sum-of-msc-2\n[exercises]\n(reduce-with xform + 0 exercises))\n{% endhighlight %}\n\nDiese Lösung liefert ebenfalls das richtige Ergebnis und offenbart einen großen Vorteil:\n\n{% highlight clojure %}\n(let [exercises (sgen/sample (s/gen ::exercises) 1000)]\n(= (time (sum-of-msc exercises))\n(time (sum-of-msc-2 exercises))))\n;; =>\n;; \"Elapsed time: 407.378092 msecs\"\n;; \"Elapsed time: 2.144632 msecs\"\n{% endhighlight %}\n\nDer Grund liegt auf der Hand: Anstatt für jeden Schritt eine neue Liste zu berechnen werden die Prozesse nacheinander für jedes Element ausgeführt.\nDamit sparen wir uns lange Zwischenergebnisse und gewinnen an Durchsatz.\n\nDiese Konzept ist so praktisch, dass es mittlerweile unter dem Namen `Transducer` Teil der Clojure-Standardbibliothek ist.\nViele Funktionen sind bereits für den Gebrauch als Transducer eingestellt (darunter die altbekannten `map`, `filter`, `mapcat`, ...).\nUnsere Funktion `reduce-with` ist dort als `transduce` definiert.\n\n## Mehr als Listen\n\nZum Abschluss noch das versprochene zweite Bespiel.\nDas Problem ist das gleiche, dieses Mal wollen wir allerdings keine Listen verwenden, sondern Channels (via `clojure.core.async`).\nHierbei schreiben wir alle Werte auf einen Channel `c` und beobachten, wie die selbe `xform` Prozessmodifikation auf ebendiese Channels anwendbar ist.\nEbenfalls verwenden wir hier nun die eingebaute Funktion `transduce`, die die Arbeit von `sum-of-msc-2` übernimmt.\n\n{% highlight clojure %}\n(ns my.namespace\n(:require [clojure.core.async :as async]\n[clojure.spec.alpha :as s]\n[clojure.spec.gen.alpha :as sgen]))\n\n(let [exercises (sgen/sample (s/gen ::exercises))\n;; Create a channel using the xform defined above.\nc (async/chan 1 xform)]\n;; Put all our elements onto the channel.\n(async/go (async/onto-chan c exercises))\n(let [chan-res (loop [;; Read one element from the channel.\nn (async/\u003C!! c)\nres 0]\n(if-not n\nres\n;; Read the next element from the channel.\n(recur (async/\u003C!! c)\n;; Accumulate the result.\n(+ res n))))\nlist-res (transduce xform + 0 exercises)]\n(= chan-res list-res)))\n;; => true\n{% endhighlight %}\n\nHier legen wir zuerst alle Elemente in den Channel (`onto-channel`).\nAnschliessen lesen wir Schritt für Schritt so lange von diesem Channel, bis keine Elemente mehr darin vorhanden sind (`\u003C!!`).\nWie wir am Ergebnis sehen, bewirkt unsere `xform` hier genau das gleiche, wie es schon bei Listen der Fall war.\nDa unserer `xform` egal ist, auf welche Datenstruktur sie arbeitet (solange sie die oben genannte Infrastruktur zur Verfügung stellt)\nlässt sie sich ohne eine Änderung ohne Probleme wiederverwenden!\n\n## Fazit\n\nTransducer sind die natürliche Fortsetzung viel verwendeter Listenfunktionen.\nIn diesem Artikel haben wir uns mit der konsequenten Abstraktion auseinandergesetzt und haben auf diesem Weg das Konzept des `Transducer`s kennen gelernt.\nNicht nur erhalten wir durch Transducer eine mächtige Beschreibung von Datentransformationen,\ndie rein auf Funktionskomposition beruht und vielseitig einsetzbar ist, sondern\ndarüber hinaus noch entscheidende Performanceverbesserungen mit sich bringt.\n\n\u003C!-- more end -->","src/content/blog/de/transducer.md","ad2ef04156733b6a",{"html":96,"metadata":97},"\u003Cp>Funktionen höherer Ordnung wie \u003Ccode>map\u003C/code>, \u003Ccode>fold\u003C/code>, \u003Ccode>filter\u003C/code> sind aus keinem funktionalen Programm wegzudenken.\nMit ihrer Flexibilität sind sie das Mittel der Wahl für Operationen auf Kollektionen aller Art.\nAllerdings beschränkt sich ihr Anwendungsbereich nicht nur auf klassische Listen oder Vektoren.\nIn diesem Artikel betrachten wir fundamentalere Eigenschaften dieser Operationen und werfen\ninsbesondere einen Blick auf die sogennanten Transducer in der Programmiersprache Clojure.\u003C/p>\n\u003C!-- more start -->\n\u003Cp>Ausserdem werden wir sehen, wie wir mit Hilfe von sinnvoller Abstraktion nicht\nnur sehr gute Wiederverwendbarkeit sondern auch eine höhere Performance erreichen\nkönnen.\u003C/p>\n\u003Ch2 id=\"alles-ist-ein-fold\">Alles ist ein fold\u003C/h2>\n\u003Cp>Wer sich in der Vergangenheit mit der funktionalen Programmierung auseinandergesetzt hat ist eventuell schon mit dieser Aussage vertraut.\nFalls Sie dazu bislang keine Gelegenheit hatten (oder Ihr Gedächtnis auffrischen wollen) betrachten wir zuerst eine Variante der üblichen Definitionen von \u003Ccode>map\u003C/code> und \u003Ccode>filter\u003C/code>.\n(Hinweis: Alle Beispiele sind in Clojure geschrieben, daher nennen wir \u003Ccode>fold\u003C/code> ab diesem Punkt bei seinem Clojure-Namen \u003Ccode>reduce\u003C/code>):\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"clojure\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> map\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">  \"Takes a function f and applies it to every element of xs.\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [f xs]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">if\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">empty?\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> xs)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    xs\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    (\u003C/span>\u003Cspan style=\"color:#B392F0\">cons\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">f\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">first\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> xs)) (\u003C/span>\u003Cspan style=\"color:#B392F0\">map\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> f (\u003C/span>\u003Cspan style=\"color:#B392F0\">rest\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> xs)))))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> filter\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">  \"Takes a predicate pred and returns a list with all elements\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">  of xs that satisfy pred.\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [pred xs]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">if\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">empty?\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> xs)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    xs\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    (\u003C/span>\u003Cspan style=\"color:#F97583\">if\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">pred\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">first\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> xs))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">      (\u003C/span>\u003Cspan style=\"color:#B392F0\">cons\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">first\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> xs) (\u003C/span>\u003Cspan style=\"color:#B392F0\">filter\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> pred (\u003C/span>\u003Cspan style=\"color:#B392F0\">rest\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> xs)))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">      (\u003C/span>\u003Cspan style=\"color:#B392F0\">filter\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> pred (\u003C/span>\u003Cspan style=\"color:#B392F0\">rest\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> xs)))))\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>So oder so ähnlich finden sich viele Defintionen und verschiedenen Standardbibliotheken.\nWie die Überschrift dieses Abschnitts schon verrät lassen sich beide Funktionen auch über \u003Ccode>fold\u003C/code> (oder eben \u003Ccode>reduce\u003C/code>) definieren.\nDie Signatur von \u003Ccode>reduce\u003C/code> sieht, in Haskellnotation ausgedrückt, so aus \u003Ccode>(b -> a -> b) -> b -> [a] -> b\u003C/code> (in diesem Fall spezialisiert für Listen).\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"clojure\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> mapping\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">  \"Takes a function f and returns a function.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">    The returned function takes a collection acc\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">    and an element x and appends x applied to f to the end of acc.\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [f]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [acc x] (\u003C/span>\u003Cspan style=\"color:#B392F0\">conj\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> acc (\u003C/span>\u003Cspan style=\"color:#B392F0\">f\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> x))))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> map\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">  \"Takes a function f and applies it to every element of xs.\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [f xs]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#B392F0\">reduce\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">mapping\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> f) [] xs))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> filtering\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">  \"Takes a predicate pred and returns a function.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">    The returned function takes a collection acc\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">    and an element x and appends x to the end of acc if it satisfies pred.\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [pred]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [acc x] (\u003C/span>\u003Cspan style=\"color:#F97583\">if\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">pred\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> x) (\u003C/span>\u003Cspan style=\"color:#B392F0\">conj\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> acc x) acc)))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> filter\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">  \"Takes a predicate pred and returns a list with all\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">    elements of xs that satisfy pred.\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [pred xs]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#B392F0\">reduce\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">filtering\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> pred) [] xs))\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Würden unsere Programme ausschließlich aus Listenverarbeitung bestehen könnten wir an dieser Stelle zufrieden aufhören.\nEtwas sticht jedoch ins Auge: sieht man einmal von dem Aufruf an \u003Ccode>conj\u003C/code> ab verraten uns die Definitionen von \u003Ccode>mapping\u003C/code> und \u003Ccode>filtering\u003C/code>\nnichts darüber, dass sie “nur” auf Kollektionen arbeiten!\u003C/p>\n\u003Ch2 id=\"von-kollektionen-zu-prozessen\">Von Kollektionen zu Prozessen\u003C/h2>\n\u003Cp>Wir haben festgestellt, dass die Verbindung zu Kollektionen von unseren \u003Ccode>mapping\u003C/code> und \u003Ccode>filtering\u003C/code> Funktionen nur über das \u003Ccode>conj\u003C/code> besteht.\nNun gehen wir einen Schritt weiter und sehen uns an was passiert, wenn wir über \u003Ccode>conj\u003C/code> abstrahieren.\nDafür ist es hilfreich nicht an Listen sondern Sequenzen von Schritten zu denken.\n\u003Ccode>mapping\u003C/code> und \u003Ccode>filtering\u003C/code> nehmen hierbei die Rolle von “Prozessmodifikationen” an: sie nehmen einen Schritt entgegen und liefern eine modifizierte Version dieses Schrittes.\nDefinieren wir also eine über diesen “Schritt” parametrisierte Version unserer Funktionen:\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"clojure\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> mapping\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [f]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [step]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [acc x] (\u003C/span>\u003Cspan style=\"color:#B392F0\">step\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> acc (\u003C/span>\u003Cspan style=\"color:#B392F0\">f\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> x)))))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> map\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [f xs]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#B392F0\">reduce\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> ((\u003C/span>\u003Cspan style=\"color:#B392F0\">mapping\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> f) conj) [] xs))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> filtering\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [pred]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [step]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [acc x] (\u003C/span>\u003Cspan style=\"color:#F97583\">if\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">pred\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> x) (\u003C/span>\u003Cspan style=\"color:#B392F0\">step\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> acc x) acc))))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> filter\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [pred xs]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#B392F0\">reduce\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> ((\u003C/span>\u003Cspan style=\"color:#B392F0\">filtering\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> pred) conj) [] acc))\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Betrachten wir nun die daraus resultierenden Definitionen von \u003Ccode>mapping\u003C/code> und \u003Ccode>filtering\u003C/code> stellen wir fest, dass die Datenstruktur, auf die diese nun operieren\nüber den \u003Ccode>step\u003C/code> Parameter festgelegt wird. Das bedeutet, dass wir nun nicht mehr von klassischen Kollektionen abhängig sind, sondern uns (wie wir später noch sehen werden),\nmehr oder weniger beliebige Datenstrukturen vornehmen und diese mit Hilfe von \u003Ccode>mapping\u003C/code> und \u003Ccode>filtering\u003C/code> verarbeiten können.\u003C/p>\n\u003Cp>Eine Überlegung für diesen Schritt steht aber noch aus: während Listen und Vektoren es einfach machen, über einen “Anfang” und ein “Ende” nachzudenken,\nvon dem wir in \u003Ccode>map\u003C/code> und \u003Ccode>filter\u003C/code> Gebrauch machen, sieht es mit Datenstrukturen wie Streams oder Signalen anders aus.\nAnstatt uns auf die Datenstruktur zu verlassen gehen wir einen anderen Weg:\u003C/p>\n\u003Col>\n\u003Cli>Unsere Transformatoren (\u003Ccode>mapping\u003C/code>, \u003Ccode>filtering\u003C/code>) sollten von sich aus ein Konzept von “Anfang” und “Ende” haben.\u003C/li>\n\u003Cli>Wir erwarten von unserer \u003Ccode>step\u003C/code> Funktion nicht nur, dass sie binär ist, sondern auch, dass sie, aufgerufen mit keinem oder einem Argument, einen “Null”-Wert produziert.\nBeispiele hierfür wären in Clojure \u003Ccode>(conj) => []\u003C/code>, \u003Ccode>(conj [1]) => [1]\u003C/code> oder \u003Ccode>(+) => 0\u003C/code>, \u003Ccode>(+ 1) => 1\u003C/code>, etc.\u003C/li>\n\u003C/ol>\n\u003Cp>Wir kümmern uns an dieser Stelle nur um Punkt 1. Wir werden zuerst eine Implementierung von \u003Ccode>mapping\u003C/code> und \u003Ccode>filtering\u003C/code> vorschlagen.\nIm Codebeispiel unten machen wir gebrauch von Clojures Syntax für “arity overloading”.\nDas heisst, wir können in einer Funktion mehrere Implementierungen für verschiedene Anzahlen von Argumenten anbieten (mehr dazu auf \u003Ca href=\"https://clojure.org/about/functional_programming#_first_class_functions\">Clojure - Functional Programming\u003C/a>).\nClojure wird hierbei abhängig von der Anzahl der übergebenen Argumente die entsprechende Implementierung wählen.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"clojure\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> mapping\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [f]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [step]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">      ([] (\u003C/span>\u003Cspan style=\"color:#B392F0\">step\u003C/span>\u003Cspan style=\"color:#E1E4E8\">))  \u003C/span>\u003Cspan style=\"color:#6A737D\">; 1.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">      ([acc] (\u003C/span>\u003Cspan style=\"color:#B392F0\">step\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> acc))  \u003C/span>\u003Cspan style=\"color:#6A737D\">; 2.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">      ([acc x] (\u003C/span>\u003Cspan style=\"color:#B392F0\">step\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> acc (\u003C/span>\u003Cspan style=\"color:#B392F0\">f\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> x)))  \u003C/span>\u003Cspan style=\"color:#6A737D\">; 3.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    )))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> filtering\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [pred]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [step]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    (\u003C/span>\u003Cspan style=\"color:#F97583\">fn\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">      ([] (\u003C/span>\u003Cspan style=\"color:#B392F0\">step\u003C/span>\u003Cspan style=\"color:#E1E4E8\">))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">      ([acc] (\u003C/span>\u003Cspan style=\"color:#B392F0\">step\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> acc))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">      ([acc x] (\u003C/span>\u003Cspan style=\"color:#F97583\">if\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">pred\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> x)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">                  (\u003C/span>\u003Cspan style=\"color:#B392F0\">step\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> acc x)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">                  acc)))))\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Auf den ersten Blick sieht das vielleicht etwas unintuitiv aus, ist aber am Beispiel von \u003Ccode>mapping\u003C/code> schnell erklärt. Die Nummerierung entspricht hier der Zahlen im obenstehenden Codebeispiel.\u003C/p>\n\u003Col>\n\u003Cli>Dieser Fall deckt den “Anfang” eines Prozesses ab. Es wurde noch nichts berechnet und es liegt noch keine “nächste” Berechnung vor.\nIn diesem Fall wollen wir von unserer \u003Ccode>step\u003C/code> Funktion ein “neutrales” Element, mit dem wir die Bechnung lostreten können.\u003C/li>\n\u003Cli>Hier signalisieren wir das “Ende” eins Prozesses. Es kommmt kein Element mehr nach, also machen wir den letzten Schritt mit dem schon vorliegenden “Ergebnis”.\u003C/li>\n\u003Cli>Schliesslich existiert noch unser Fall, der das aktuelle Ergebnis und ein Element miteinander verarbeitet.\u003C/li>\n\u003C/ol>\n\u003Cp>Diese Funktionen sind nun so weit parametrisiert, dass wir beliebige Prozesse damit ausdrücken und, vermutlich noch wichtiger, mehrere solcher Prozessmodifikationen\nhintereinander ausführen (oder komponieren) können!\u003C/p>\n\u003Cp>Wie sieht das in der Realität aus?\u003C/p>\n\u003Ch2 id=\"beispiele-für-prozessmodifikatoren\">Beispiele für Prozessmodifikatoren\u003C/h2>\n\u003Cp>Im Folgenden geben wir zwei Beispiele dafür, wie uns das Ganze nun in der echten Welt hilft und wann wir dieses Vorgehen möglicherweise der regulären Verkettung von Listenoperationen vorziehen wollen.\u003C/p>\n\u003Cp>In beiden Beispielen beschäftigen wir uns mit folgendem Problem:\nDas Semester ist zuende und die Professorin möchte wissen, wie gut die Durchschnittliche Leistung ihrer Masterstudent*innen im Übungsbetrieb war.\nMit Hilfe von Clojure-Spec definieren wir einige Beispieldaten.\nDie ersten vier Zeilen definieren die “Form” unserer Daten.\nDabei ist z.B. \u003Ccode>::title\u003C/code> ein Wert, der das \u003Ccode>string?\u003C/code>-Prädikat erfüllt, in der\nfünften Zeile geben wir \u003Ccode>::exercise\u003C/code> als als Map mit den Schlüsseln an, die\ndarüber definiert wurden.\nDie Ausgabe von \u003Ccode>sample\u003C/code> wurde hier etwas aufgehübscht, das tatsächliche Ergbnis\nsähe wohl etwas offentichtlich zufälliger aus.\nWer mehr zu Spec erfahren möchte kann das\n\u003Ca href=\"http://funktionale-programmierung.de/2016/11/18/clojure-spec.html\">in einem älteren Blog-Artikel tun\u003C/a>.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"clojure\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">ns\u003C/span>\u003Cspan style=\"color:#B392F0\"> my.namespace\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#79B8FF\">:require\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [clojure.spec.alpha \u003C/span>\u003Cspan style=\"color:#79B8FF\">:as\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> s]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">            [clojure.spec.gen.alpha \u003C/span>\u003Cspan style=\"color:#79B8FF\">:as\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> sgen]))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">s/def\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::title\u003C/span>\u003Cspan style=\"color:#B392F0\"> string?\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">s/def\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::student\u003C/span>\u003Cspan style=\"color:#B392F0\"> string?\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">s/def\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::points\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">set\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">range\u003C/span>\u003Cspan style=\"color:#79B8FF\"> 31\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">s/def\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::degree\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> #{\u003C/span>\u003Cspan style=\"color:#79B8FF\">::msc\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::bsc\u003C/span>\u003Cspan style=\"color:#E1E4E8\">})\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">s/def\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::exercise\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">s/keys\u003C/span>\u003Cspan style=\"color:#79B8FF\"> :req\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [\u003C/span>\u003Cspan style=\"color:#79B8FF\">::title\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::student\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::points\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::degree\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;; `sample` takes a generator for our `spec` and returns some random data that\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;; matches this spec.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#B392F0\">sgen/sample\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">s/gen\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::exercise\u003C/span>\u003Cspan style=\"color:#E1E4E8\">))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;; =>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;; [{::name \"Marco\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;;   ::title \"Exercise 1\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;;   ::points 29\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;;   ::degree ::msc}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;;  {::name \"Mathias\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;;   ::title \"Exercise 1\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;;   ::points 28\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;;   ::degree ::bsc}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">;;  ...]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">```clojure\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">Zurück zu unserer Aufgabe. Diese liesse sich mit regulären Listenfunktionen zum\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">Beispiel so lösen:\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">```clojure\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> sum-of-msc\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [exercises]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#B392F0\">reduce\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> + \u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">->>\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> exercises\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">                    (\u003C/span>\u003Cspan style=\"color:#B392F0\">filter\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> #(\u003C/span>\u003Cspan style=\"color:#B392F0\">=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::msc\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#79B8FF\">::degree\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> %)))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">                    (\u003C/span>\u003Cspan style=\"color:#B392F0\">map\u003C/span>\u003Cspan style=\"color:#79B8FF\"> ::handins\u003C/span>\u003Cspan style=\"color:#E1E4E8\">))))\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Angewendet auf eine Liste von Übungen liefert es uns das richtige Ergebnis.\nEs gibt allerdings ein Problem: Jeder Aufruf von \u003Ccode>filter\u003C/code>, \u003Ccode>map\u003C/code> und \u003Ccode>reduce\u003C/code> berechnet eine neue Liste!\nBei großen Mengen kann das, wie wir gleich sehen werden, durchaus zu Problemen führen.\u003C/p>\n\u003Cp>Als nächstes implementieren wir die gleiche Funktionalität, ausgedrückt über unsere neu definierten Operatoren.\u003C/p>\n\u003Cp>Der erste Schritt wird eine leicht modifizierte Version von \u003Ccode>reduce\u003C/code> names\n\u003Ccode>reduce-with\u003C/code> sein. Diese funktioniert ganz ähnlich wie \u003Ccode>reduce\u003C/code>, ausser, dass sie\nzusätzlich zur Reduktionsfunktion (hier \u003Ccode>step\u003C/code>) einen Paramterer \u003Ccode>xf\u003C/code> erwartet,\nwelcher eine Komposition unserer Funktionen darstellt.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"clojure\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#F97583\">defn\u003C/span>\u003Cspan style=\"color:#B392F0\"> reduce-with\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">  \"Takes a function composed of process modifications xf,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">    a step function,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">    an initial value and a sequence of operations.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#9ECBFF\">    Applies xf with a step to every x in xs.\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  [xf step init xs]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  (\u003C/span>\u003Cspan style=\"color:#F97583\">let\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> [f (\u003C/span>\u003Cspan style=\"color:#B392F0\">xf\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> step)]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    (\u003C/span>\u003Cspan style=\"color:#B392F0\">f\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#B392F0\">reduce\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> f init xs))))\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Im Inneren der Funktion rufen wir wie gewohnt \u003Ccode>reduce\u003C/code> auf.\nAls Reduktionsfunktion kommt allerdings die Kompositionsfunktion \u003Ccode>xf\u003C/code> zum Einsatz,\nwelche über den \u003Ccode>step\u003C/code> Parameter (selbst eine Funktion) für die Auswertung spezialisiert und\nand \u003Ccode>f\u003C/code> gebunden wird.\nAnschliessend wird reduziert und das Ergebnis zum Schluss noch einmal mit \u003Ccode>f\u003C/code>\naufgerufen, um ein finales Ergebnis zu erzeugen.\u003C/p>\n\u003Cp>Wie muss allerdings das \u003Ccode>xf\u003C/code> aussehen?\nDiese Funktion ist, ganz analog zu \u003Ccode>sum-of-msc\u003C/code> oben, ebenfalls eine Komposition\nvon \u003Ccode>filtering\u003C/code> und \u003Ccode>mapping\u003C/code>. Wir nennen sie an dieser Stelle \u003Ccode>xform\u003C/code> (eine\nKonvention in der Clojurewelt).\u003C/p>\n\u003Cp>{% highlight clojure %}\n;; Compose two process modificators into one.\n(def xform (comp\n(filtering #(= ::msc (::degree %)))\n(mapping ::points)))\n{% endhighlight %}\u003C/p>\n\u003Cp>Eventuell fragen Sie sich zurecht, warum sich die Reihenfolge der Aufrufe von \u003Ccode>filtering\u003C/code>\nund \u003Ccode>mapping\u003C/code> nicht verändert, da Komposition “von rechts nach links” ausgewertet\nwird, das Threading in unserer \u003Ccode>sum-of-msc\u003C/code> aber von “links nach rechts” passiert.\nAn dieser Stelle würde die vollständige Antwort den Rahmen sprengen. Wir merken\nuns für den Moment einfach, dass die Komposition dieser Art von Funktion ebenfalls\n“von rechts nach links” auswertet.\nSie können das sehr leicht herausfinden, indem sie die Kopmposition der Funktionen\neinmal von Hand vollständig reduzieren.\u003C/p>\n\u003Cp>{% highlight clojure %}\n(defn sum-of-msc-2\n[exercises]\n(reduce-with xform + 0 exercises))\n{% endhighlight %}\u003C/p>\n\u003Cp>Diese Lösung liefert ebenfalls das richtige Ergebnis und offenbart einen großen Vorteil:\u003C/p>\n\u003Cp>{% highlight clojure %}\n(let [exercises (sgen/sample (s/gen ::exercises) 1000)]\n(= (time (sum-of-msc exercises))\n(time (sum-of-msc-2 exercises))))\n;; =>\n;; “Elapsed time: 407.378092 msecs”\n;; “Elapsed time: 2.144632 msecs”\n{% endhighlight %}\u003C/p>\n\u003Cp>Der Grund liegt auf der Hand: Anstatt für jeden Schritt eine neue Liste zu berechnen werden die Prozesse nacheinander für jedes Element ausgeführt.\nDamit sparen wir uns lange Zwischenergebnisse und gewinnen an Durchsatz.\u003C/p>\n\u003Cp>Diese Konzept ist so praktisch, dass es mittlerweile unter dem Namen \u003Ccode>Transducer\u003C/code> Teil der Clojure-Standardbibliothek ist.\nViele Funktionen sind bereits für den Gebrauch als Transducer eingestellt (darunter die altbekannten \u003Ccode>map\u003C/code>, \u003Ccode>filter\u003C/code>, \u003Ccode>mapcat\u003C/code>, …).\nUnsere Funktion \u003Ccode>reduce-with\u003C/code> ist dort als \u003Ccode>transduce\u003C/code> definiert.\u003C/p>\n\u003Ch2 id=\"mehr-als-listen\">Mehr als Listen\u003C/h2>\n\u003Cp>Zum Abschluss noch das versprochene zweite Bespiel.\nDas Problem ist das gleiche, dieses Mal wollen wir allerdings keine Listen verwenden, sondern Channels (via \u003Ccode>clojure.core.async\u003C/code>).\nHierbei schreiben wir alle Werte auf einen Channel \u003Ccode>c\u003C/code> und beobachten, wie die selbe \u003Ccode>xform\u003C/code> Prozessmodifikation auf ebendiese Channels anwendbar ist.\nEbenfalls verwenden wir hier nun die eingebaute Funktion \u003Ccode>transduce\u003C/code>, die die Arbeit von \u003Ccode>sum-of-msc-2\u003C/code> übernimmt.\u003C/p>\n\u003Cp>{% highlight clojure %}\n(ns my.namespace\n(:require [clojure.core.async :as async]\n[clojure.spec.alpha :as s]\n[clojure.spec.gen.alpha :as sgen]))\u003C/p>\n\u003Cp>(let [exercises (sgen/sample (s/gen ::exercises))\n;; Create a channel using the xform defined above.\nc (async/chan 1 xform)]\n;; Put all our elements onto the channel.\n(async/go (async/onto-chan c exercises))\n(let [chan-res (loop [;; Read one element from the channel.\nn (async/&#x3C;!! c)\nres 0]\n(if-not n\nres\n;; Read the next element from the channel.\n(recur (async/&#x3C;!! c)\n;; Accumulate the result.\n(+ res n))))\nlist-res (transduce xform + 0 exercises)]\n(= chan-res list-res)))\n;; => true\n{% endhighlight %}\u003C/p>\n\u003Cp>Hier legen wir zuerst alle Elemente in den Channel (\u003Ccode>onto-channel\u003C/code>).\nAnschliessen lesen wir Schritt für Schritt so lange von diesem Channel, bis keine Elemente mehr darin vorhanden sind (\u003Ccode>&#x3C;!!\u003C/code>).\nWie wir am Ergebnis sehen, bewirkt unsere \u003Ccode>xform\u003C/code> hier genau das gleiche, wie es schon bei Listen der Fall war.\nDa unserer \u003Ccode>xform\u003C/code> egal ist, auf welche Datenstruktur sie arbeitet (solange sie die oben genannte Infrastruktur zur Verfügung stellt)\nlässt sie sich ohne eine Änderung ohne Probleme wiederverwenden!\u003C/p>\n\u003Ch2 id=\"fazit\">Fazit\u003C/h2>\n\u003Cp>Transducer sind die natürliche Fortsetzung viel verwendeter Listenfunktionen.\nIn diesem Artikel haben wir uns mit der konsequenten Abstraktion auseinandergesetzt und haben auf diesem Weg das Konzept des \u003Ccode>Transducer\u003C/code>s kennen gelernt.\nNicht nur erhalten wir durch Transducer eine mächtige Beschreibung von Datentransformationen,\ndie rein auf Funktionskomposition beruht und vielseitig einsetzbar ist, sondern\ndarüber hinaus noch entscheidende Performanceverbesserungen mit sich bringt.\u003C/p>\n\u003C!-- more end -->",{"headings":98,"localImagePaths":114,"remoteImagePaths":115,"frontmatter":116,"imagePaths":118},[99,102,105,108,111],{"depth":28,"slug":100,"text":101},"alles-ist-ein-fold","Alles ist ein fold",{"depth":28,"slug":103,"text":104},"von-kollektionen-zu-prozessen","Von Kollektionen zu Prozessen",{"depth":28,"slug":106,"text":107},"beispiele-für-prozessmodifikatoren","Beispiele für Prozessmodifikatoren",{"depth":28,"slug":109,"text":110},"mehr-als-listen","Mehr als Listen",{"depth":28,"slug":112,"text":113},"fazit","Fazit",[],[],{"description":90,"title":90,"date":117},["Date","2018-03-22T00:00:00.000Z"],[],"de/transducer.md"]